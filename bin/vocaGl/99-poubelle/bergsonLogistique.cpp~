void bergson::afficherListe(){
  afficherListeDessin1 ();
  afficherListeDessin2 ();
  gestionListe_affichageMenuHorizontal();
  //  gestionListe_affichageMenuVertical();
  afficherListeTexte   ();
}

void bergson::interrogation(){
  /* Clear the window. */
  glClearColor(0.0,0.0,0.0,0.0);
  glClear(GL_COLOR_BUFFER_BIT);

  afficherListe();
  if(!pause) {
    glutSwapBuffers();
    glutPostRedisplay();
  }
}

void bergson::my_handle_key(unsigned char key, int x, int y) {
  tableBergson maTableVide2;
  switch (key) {
  case 'a': case 'A': gestionListe_gestionCurseur(-1); break;
  case 'z': case 'Z': gestionListe_gestionCurseur(+1); break;
    
  case 'v': case 'V': Bdd[posxCurseur].flagVisible         = !Bdd[posxCurseur].flagVisible; break;
  case 'c': case 'C': Bdd[posxCurseur].flagQuestionVisible = !Bdd[posxCurseur].flagQuestionVisible; break;
  case 'n': case 'N': Bdd.push_back(maTableVide2);
    break;
  case 'b': case 'B': Bdd[posxCurseur].flagMemoVisible     = !Bdd[posxCurseur].flagMemoVisible; break;
    
  case '-': offsety-=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?0.3:0.1);    break;
  case '+': offsety+=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?0.3:0.1);    break;

  case 27:              exit(1);           break;
  case 'p': case 'P':   pause = !pause;    break;
  case 's': case 'S':   saveMetaData();    break;
  case 'l': case 'L':   loadMetaData();    break;
  default:  break;
} }

//#############################################
//#############################################

int bergson::loadMetaData() {
  ifstream in(fileName, std::ios::binary);
  in.unsetf(std::ios::skipws);
  int oldTailleBdd = Bdd.size();
  int tailleBdd;
  
  //## LECTURE DES MÉTADONNÉES GLOBALES #########
  RECORD   s_Lego;
  RECORD_F f_Lego;
  RECORD_I i_Lego;

  f_Lego.loadBinaire(&in);
  i_Lego.loadBinaire(&in);
  s_Lego.loadBinaire(&in);
  
  pos[X]            = f_Lego[0];
  pos[Y]            = f_Lego[1];
  ratio[X]          = f_Lego[2];
  ratio[Y]          = f_Lego[3];
  old[X]            = f_Lego[4];
  old[Y]            = f_Lego[5];
  offsety           = f_Lego[6];

  pause             = i_Lego[0];
  leftState         = i_Lego[1];
  rightState        = i_Lego[2];
  nearestTableIndex = i_Lego[3];
  posxCurseur       = i_Lego[4];
  tailleBdd         = i_Lego[5];

  fileName2         = s_Lego[0];
  cout << "fileName:" << fileName << endl;

  //## LECTURE DES TABLES ###########
  for (int i=0; i< oldTailleBdd; i++) 
    Bdd.erase(Bdd.begin());

  for (int i=0; i< tailleBdd; i++) {
    tableBergson maTableVide;
    maTableVide.loadBinaire(&in);
    Bdd.push_back(maTableVide);
  }
  
  //## LECTURE DES MÉTADONNÉES DES TABLES ######
  for (int i=0; i < Bdd.size(); i++) {
    RECORD_F f_Liste;
    RECORD_D d_Liste;
    RECORD_I i_Liste;
    RECORD s_Liste;
    
    f_Liste.loadBinaire(&in);
    d_Liste.loadBinaire(&in);
    i_Liste.loadBinaire(&in);
    s_Liste.loadBinaire(&in);
    
    Bdd[i].color[R]=		 f_Liste[0];
    Bdd[i].color[G]=	       	 f_Liste[1];
    Bdd[i].color[B]=	       	 f_Liste[2];
    Bdd[i].color[A]=             f_Liste[3];

    Bdd[i].pos[X]=		 d_Liste[0];

    Bdd[i].flagVisible=	         i_Liste[0];
    Bdd[i].flagQuestionVisible=  i_Liste[1];
    Bdd[i].flagMemoVisible=      i_Liste[2];

    Bdd[i].filename.assign(      s_Liste[0]);
  }
  
  in.close();
  return true;
}

//#############################################
//#############################################

int bergson::saveMetaData() {
  ofstream out(fileName, std::ios::binary);
  out.unsetf(std::ios::skipws);

  //## SAUVEGARDE DES MÉTADONNÉES GLOBALES ####
  
  RECORD   s_Lego;
  RECORD_F f_Lego;
  RECORD_I i_Lego;
  
  f_Lego.push_back(pos[X]);
  f_Lego.push_back(pos[Y]);
  f_Lego.push_back(ratio[X]);
  f_Lego.push_back(ratio[Y]);
  f_Lego.push_back(old[X]);
  f_Lego.push_back(old[Y]);
  f_Lego.push_back(offsety);
  f_Lego.saveBinaire(&out);
  
  i_Lego.push_back(pause);
  i_Lego.push_back(leftState);
  i_Lego.push_back(rightState);
  i_Lego.push_back(nearestTableIndex);
  i_Lego.push_back(posxCurseur);
  i_Lego.push_back(Bdd.size());
  i_Lego.saveBinaire(&out);
  
  s_Lego.push_back(fileName);
  s_Lego.saveBinaire(&out);
  
  //## SAUVEGARDE DES TABLES #######
  //  out.setf(std::ios::skipws);
  for (int i=0; i< Bdd.size(); i++)
    Bdd[i].saveBinaire(&out);

  //## SAUVEGARDE DES MÉTADONNÉES DES TABLES ##
  for (int i=0; i < Bdd.size(); i++) {
    RECORD_F f_Liste;
    RECORD_D d_Liste;
    RECORD_I i_Liste;
    RECORD   s_Liste;
    
    f_Liste.push_back(Bdd[i].color[R]);
    f_Liste.push_back(Bdd[i].color[G]);	       
    f_Liste.push_back(Bdd[i].color[B]);	       
    f_Liste.push_back(Bdd[i].color[A]);            
    d_Liste.push_back(Bdd[i].pos[X]);
    i_Liste.push_back(Bdd[i].flagVisible);
    i_Liste.push_back(Bdd[i].flagQuestionVisible);
    i_Liste.push_back(Bdd[i].flagMemoVisible);
    s_Liste.push_back(Bdd[i].filename);
    
    f_Liste.saveBinaire(&out);
    d_Liste.saveBinaire(&out);
    i_Liste.saveBinaire(&out);
    s_Liste.saveBinaire(&out);
  }
  
  out.close();
  return true;
}

//#############################################
//#############################################

bergson::bergson(int argc, char * argv[]): openGlInterface(argc, argv){
  //C'est ici que l'on s'occupe du chargement des fichiers.
  if (argc!=2) {
    cout << "usage: " << argv[0]
	 << " [fichier.lst | fichier.bin | fichier.txt]" << endl;
  }
  //récupérer l'extension
  string nomFichier(argv[1]);
  string extension = nomFichier.substr(nomFichier.length()-4, nomFichier.length()-1);
  cout << extension << endl;
  cout << nomFichier << endl;
  posxCurseur=0;

  //pour la sauvegarde binaire
  fileName = argv[1];
  
  //## fichier isolé #######################################
  if (extension.compare(".txt")==0){
    tableBergson maTableVide;
    Bdd.push_back(maTableVide);
    Bdd.back().importDriver(nomFichier);
    Bdd[0].filename.assign(nomFichier);
    Bdd[0].color[R]            = 0.0;
    Bdd[0].color[G]	         = 1.0;
    Bdd[0].color[B]	         = 1.0;
    Bdd[0].color[A]            = 1.0;
    Bdd[0].pos[X]	         = 0.0;
    Bdd[0].flagVisible         = 1;
    Bdd[0].flagQuestionVisible = 1;
    Bdd[0].flagMemoVisible     = 1;

//  ofstream tmpOut("cronimousHumain.txt");
//  Bdd[0].saveHumain(&tmpOut);
//  tmpOut.close();
  }
  //## liste de fichiers ###################################
  else   if (extension.compare(".lst")==0){
    fileNameListe.assign(nomFichier);
    maListeDeListe.importDriver(nomFichier);
    
    for (int i=0; i < maListeDeListe.size(); i++) {
      tableBergson maTableVide;
      Bdd.push_back(maTableVide);
      Bdd.back().importDriver(maListeDeListe[i][0]);
      Bdd[i].filename.assign(maListeDeListe[i][0]);
      Bdd[i].color[R]            = stof(maListeDeListe[i][1]);
      Bdd[i].color[G]	       = stof(maListeDeListe[i][2]);
      Bdd[i].color[B]	       = stof(maListeDeListe[i][3]);
      Bdd[i].color[A]            = stof(maListeDeListe[i][4]);
      Bdd[i].pos[X]	       = stod(maListeDeListe[i][5]);
      Bdd[i].flagVisible         = stoi(maListeDeListe[i][6]);
      Bdd[i].flagQuestionVisible = stoi(maListeDeListe[i][7]);
      Bdd[i].flagMemoVisible     = stoi(maListeDeListe[i][8]);
    }
  }
  //## fichier binaire #####################################
  else   if (extension.compare(".bin")==0){
    loadMetaData();
  }
  //########################################################

  //pour la sauvegarde binaire.
  // Attention, loadMetaData se sert de ce nom.
  fileName = fileName + ".save";

  //  monDico.importDriver          ("listes/dico.txt");
  monDico.importDriver          ("listes/cronimousHumain3.txt");
  monHauftisteWorte.importDriver("listes/haufigstenWorte.txt");
  monHauftisteWorte.importDriver("listes/dico.txt");
  prefixe.importDriver          ("listes/prefixe.txt");
  suffixe.importDriver          ("listes/suffixes.txt");
  
  glutKeyboardFunc(my_handle_key);
}
