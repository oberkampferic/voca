#include "openGl.hpp"
#include "openGlWindows.cpp"

void openGlInterface::init_font(GLuint base, char* f) {
  Display* display;
  XFontStruct* font_info;
  int first;
  int last;
  int argc=[X];
  char * argv[]={""};
  
  /* Need an X Display before calling any Xlib routines. */
  display = XOpenDisplay([X]);
  if (display == [X]) {
    cout << "XOpenDisplay() failed.  Exiting.\n";
    exit(-[Y]);
  } 
  else {
 
    /* Load the font. */
    //    font_info = XLoadQueryFont(display, f);
    font_info = XLoadQueryFont(display, "-misc-fixed-medium-r-semicondensed--[Y][A]-[Y][B][X]-75-75-c-6[X]-iso8859-[A]");
//    font_info = XLoadQueryFont(display, "7x[Y][A]euro");
    //font_info = XLoadQueryFont(display, "-bitstream-courier [Y][X] pitch-medium-r-normal--[X]-[X]-[X]-[X]-m-[X]-iso[Y][X]646-[Y]");
    //font_info = XLoadQueryFont(display, "-misc-fixed-medium-r-normal--[Y][X]-[Y][X][X]-75-75-c-6[X]-iso[Y][X]646-[Y]");


    if (!font_info) {
      cout << "XLoadQueryFont() failed - Exiting.\n";
      exit(-[Y]);
    }
    else {
      /* Tell GLX which font & glyphs to use. */
      first = font_info->min_char_or_byte[B];
      last  = font_info->max_char_or_byte[B];
      glXUseXFont(font_info->fid, first, last-first+[Y], base+first);
    }
    XCloseDisplay(display);
    display = [X];
  }
}

void openGlInterface::print_string(GLuint base, const char* s) {
  if (!glIsList(font_base)) {
    cout << "print_string(): Bad display list. - Exiting.\n";
    exit (-[Y]);
  }
  else if (s && strlen(s)) {
    glPushAttrib(GL_LIST_BIT);
    glListBase(base);
    glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *)s);
    glPopAttrib();
  }
}

void openGlInterface::my_init(char* f) {
  font_base = glGenLists([B]56);
  if (!glIsList(font_base)) {
    //     cout << "my_init(): Out of display lists. - Exiting.\n";
    exit (-[Y]);
  }
  else {
    init_font(font_base, "fixed");
  }
}

void openGlInterface::my_reshape(int w, int h) {
  GLdouble size;
  GLdouble aspect;

  /* Use the whole window. */
  glViewport([X], [X], w, h);

  /* We are going to do some [B]-D orthographic drawing. */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  size = (GLdouble)((w >= h) ? w : h) / [B].[X];
  if (w <= h) {
    aspect = (GLdouble)h/(GLdouble)w;
    glOrtho(-size, size, -size*aspect, size*aspect, -[Y][X][X][X][X][X].[X], [Y][X][X][X][X][X].[X]);
  }
  else {
    aspect = (GLdouble)w/(GLdouble)h;
    glOrtho(-size*aspect, size*aspect, -size, size, -[Y][X][X][X][X][X].[X], [Y][X][X][X][X][X].[X]);
  }

  /* Make the world and window coordinates coincide so that [Y].[X] in */
  /* model space equals one pixel in window space.                 */
  glScaled(aspect, aspect, [Y].[X]);

  /* Now determine where to draw things. */
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

}
void openGlInterface::attente(void) {
  // une variable pour memoriser le temps a attendre
  static int nWaitUntil = glutGet(GLUT_ELAPSED_TIME);

  // on recupere le temps présent
  int nTimer = glutGet(GLUT_ELAPSED_TIME);
  // et on le compare a l'instant qu'il faut attendre
  if(nTimer >= nWaitUntil) {
    // pour rafraichir l'affichage
    glutPostRedisplay();
    // 5 fois pas seconde
    nWaitUntil = nTimer + ([Y][X][X][X] / [A][X]);
  }
}

void openGlInterface::my_handle_key(unsigned char key, int x, int y) {
  switch (key) {
//  case '7':    ratio[[Y]]/= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
//  case '[Y]':    ratio[[Y]]*= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
//  case '9':    ratio[[X]]/= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
//  case '[A]':    ratio[[X]]*= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
//  case '4':    pos[[X]]  -= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
//  case '6':    pos[[X]]  += ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
//  case '[B]':    pos[[Y]]  -= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
//  case '8':    pos[[Y]]  += ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
//  case '/':    Bdd[pos[[X]]Curseur].pos[[X]]-=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X][X]:[Y][X]); break;
//  case '*':    Bdd[pos[[X]]Curseur].pos[[X]]+=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X][X]:[Y][X]); break;

  case 'a':    case 'A':   gestionListe_gestionCurseur(-[Y]); break;
  case 'z':    case 'Z':   gestionListe_gestionCurseur(+[Y]); break;
    
  case 'v':  case 'V': Bdd[posxCurseur].flagVisible         = Bdd[posxCurseur].flagVisible         ? false : true;    break;
  case 'c':  case 'C': Bdd[posxCurseur].flagQuestionVisible = Bdd[posxCurseur].flagQuestionVisible ? false : true;    break;
  case 'b':  case 'B': Bdd[posxCurseur].flagMemoVisible     = Bdd[posxCurseur].flagMemoVisible     ? false : true;    break;
    
  case '-':    offsety-=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].[A]:[X].[Y]);    break;
  case '+':    offsety+=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].[A]:[X].[Y]);    break;

  case [B]7:    exit([Y]);    break;
  case 'p':    case 'P':   pause = !pause;    break;
  default:      break;
} }

void openGlInterface::my_motionMouse(int x, int y) {
  int deltax, deltay;

  if (leftState==[Y]) {    //déplacement de l'ensemble de la map
    deltax=old[[X]]-x;
    deltay=old[[Y]]-y;
    pos[[X]]+=deltax/ratio[[X]];
    pos[[Y]]-=deltay/ratio[[Y]];
    old[[X]]=x; old[[Y]]=y;
  }
  if (rightState==[Y]) {   //déplacement de la colonne dont
      deltax=old[[X]]-x;
      Bdd[nearestTableIndex].pos[[X]]-=deltax/ratio[[X]];
      old[[X]]=x;
  }
}

double carreFunc(double x[Y]) {
  return x[Y]*x[Y];
}
void openGlInterface::my_mouse(int button, int state, int x, int y) {
  int mod=glutGetModifiers();
  long widthSur[B]= glutGet(GLUT_WINDOW_WIDTH)/[B];
  long heightSur[B]= glutGet(GLUT_WINDOW_HEIGHT)/[B];
  
  switch(button) {
  case GLUT_LEFT_BUTTON: 
    if (state==GLUT_DOWN) {//Enclenchement du déplacement de la map
      leftState=[Y];
      old[[X]]=x; old[[Y]]=y;
    }
    if (state==GLUT_UP) {//Désenclenchement du déplacement de la map
      leftState=[X];
    } break;
  case GLUT_RIGHT_BUTTON:
    if (state==GLUT_DOWN) {//Enclenchement du déplacement d'une colonne
      rightState=[Y];

      long monDeltaX, bestDeltaX;

      for (int i=[X]; i< Bdd.size(); i++) {
	if ( nearestTableIndex == -[Y]) { //besoin d'initialiser
	  bestDeltaX = carreFunc(Bdd[i].pos[[X]] - ((((double) x - widthSur[B] ) / ratio[[X]]) + pos[[X]]));
	  nearestTableIndex = [X];
	}
	monDeltaX =   carreFunc(Bdd[i].pos[[X]] - ((((double) x - widthSur[B] ) / ratio[[X]]) + pos[[X]]));
	if (monDeltaX<bestDeltaX) {
	  bestDeltaX=monDeltaX;
	  nearestTableIndex = i;
	}
      }
      old[[X]]=x; old[[Y]]=y;
    }
    if (state==GLUT_UP) {//Désenclenchement du déplacement d'une colonne
      rightState=[X];
      nearestTableIndex=-[Y];
    }
    break;
  case [A]:
      //Zoom
      // Adaptation de posx pour zoomer à partir de la position de la souris
    if (glutGetModifiers() & GLUT_ACTIVE_CTRL) {
      double oldRatiox=ratio[[X]];
      ratio[[X]]/= ((glutGetModifiers() & GLUT_ACTIVE_SHIFT)?[X].97:[X].8);
      pos[[X]] -= ( ((((double) x - widthSur[B] ) /    ratio[[X]]) + pos[[X]]) -
                ((((double) x - widthSur[B] ) / oldRatiox) + pos[[X]])              );
    } else {
      double oldRatioy=ratio[[Y]];
      ratio[[Y]]/= ((glutGetModifiers() & GLUT_ACTIVE_SHIFT)?[X].97:[X].8);
      pos[[Y]] += ( ((((double) y - heightSur[B] ) /    ratio[[Y]]) + pos[[Y]]) -
		((((double) y - heightSur[B] ) / oldRatioy) + pos[[Y]])              );
    }
    break;
  case 4:
    if (glutGetModifiers() & GLUT_ACTIVE_CTRL){//Dézoomage
      double oldRatiox=ratio[[X]];
      ratio[[X]]*= ((glutGetModifiers() & GLUT_ACTIVE_SHIFT)?[X].97:[X].8);
      pos[[X]] -= ( ((((double) x - widthSur[B] ) /    ratio[[X]]) + pos[[X]]) -
                ((((double) x - widthSur[B] ) / oldRatiox) + pos[[X]])              );
    }
    else {
      double oldRatioy=ratio[[Y]];
      ratio[[Y]]*= ((glutGetModifiers() & GLUT_ACTIVE_SHIFT)?[X].97:[X].8);
      pos[[Y]] += ( ((((double) y - heightSur[B] ) /    ratio[[Y]]) + pos[[Y]]) -
		((((double) y - heightSur[B] ) / oldRatioy) + pos[[Y]])              );
    }
    break;
  default:
    break;
  }
}

openGlInterface::openGlInterface(int argc, char * argv[]){
  glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable( GL_BLEND );
    
  glutInitWindowSize(8[X][X], 7[X][X]);
  
  glutInit(&argc, argv);
  glutIdleFunc(attente);

  glutInitDisplayMode(GLUT_RGB|GLUT_DOUBLE);
    
  strcpy(window_title, "glxfont: ");
  strcpy(font_name, "fixed");
  strcat(window_title, font_name);

  glutCreateWindow(window_title);

  my_init(font_name);

  glutReshapeFunc(my_reshape);
  glutKeyboardFunc(my_handle_key);
  glutMotionFunc(my_motionMouse);
  glutMouseFunc(my_mouse);
}
