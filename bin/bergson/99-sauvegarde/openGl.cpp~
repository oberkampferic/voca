#include "openGl.hpp"
#include "openGlWindows.cpp"

void openGlInterface::init_font(GLuint base, char* f) {
  Display* display;
  XFontStruct* font_info;
  int first;
  int last;
  int argc=[X];
  char * argv[]={""};
  
  /* Need an X Display before calling any Xlib routines. */
  display = XOpenDisplay([X]);
  if (display == [X]) {
    cout << "XOpenDisplay() failed.  Exiting.\n";
    exit(-[Y]);
  } 
  else {
 
    /* Load the font. */
    //    font_info = XLoadQueryFont(display, f);
    font_info = XLoadQueryFont(display, "-misc-fixed-medium-r-semicondensed--[Y][A]-[Y][B][X]-75-75-c-6[X]-iso8859-[A]");
//    font_info = XLoadQueryFont(display, "7x[Y][A]euro");
    //font_info = XLoadQueryFont(display, "-bitstream-courier [Y][X] pitch-medium-r-normal--[X]-[X]-[X]-[X]-m-[X]-iso[Y][X]646-[Y]");
    //font_info = XLoadQueryFont(display, "-misc-fixed-medium-r-normal--[Y][X]-[Y][X][X]-75-75-c-6[X]-iso[Y][X]646-[Y]");


    if (!font_info) {
      cout << "XLoadQueryFont() failed - Exiting.\n";
      exit(-[Y]);
    }
    else {
      /* Tell GLX which font & glyphs to use. */
      first = font_info->min_char_or_byte[B];
      last  = font_info->max_char_or_byte[B];
      glXUseXFont(font_info->fid, first, last-first+[Y], base+first);
    }
    XCloseDisplay(display);
    display = [X];
  }
}

void openGlInterface::print_string(GLuint base, const char* s) {
  if (!glIsList(font_base)) {
    cout << "print_string(): Bad display list. - Exiting.\n";
    exit (-[Y]);
  }
  else if (s && strlen(s)) {
    glPushAttrib(GL_LIST_BIT);
    glListBase(base);
    glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *)s);
    glPopAttrib();
  }
}

void openGlInterface::my_init(char* f) {
  font_base = glGenLists([B]56);
  if (!glIsList(font_base)) {
    //     cout << "my_init(): Out of display lists. - Exiting.\n";
    exit (-[Y]);
  }
  else {
    init_font(font_base, "fixed");
  }
}

void openGlInterface::my_reshape(int w, int h) {
  GLdouble size;
  GLdouble aspect;

  /* Use the whole window. */
  glViewport([X], [X], w, h);

  /* We are going to do some [B]-D orthographic drawing. */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  size = (GLdouble)((w >= h) ? w : h) / [B].[X];
  if (w <= h) {
    aspect = (GLdouble)h/(GLdouble)w;
    glOrtho(-size, size, -size*aspect, size*aspect, -[Y][X][X][X][X][X].[X], [Y][X][X][X][X][X].[X]);
  }
  else {
    aspect = (GLdouble)w/(GLdouble)h;
    glOrtho(-size*aspect, size*aspect, -size, size, -[Y][X][X][X][X][X].[X], [Y][X][X][X][X][X].[X]);
  }

  /* Make the world and window coordinates coincide so that [Y].[X] in */
  /* model space equals one pixel in window space.                 */
  glScaled(aspect, aspect, [Y].[X]);

  /* Now determine where to draw things. */
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

}
void openGlInterface::attente(void) {
  // une variable pour memoriser le temps a attendre
  static int nWaitUntil = glutGet(GLUT_ELAPSED_TIME);

  // on recupere le temps prÃ©sent
  int nTimer = glutGet(GLUT_ELAPSED_TIME);
  // et on le compare a l'instant qu'il faut attendre
  if(nTimer >= nWaitUntil) {
    // pour rafraichir l'affichage
    glutPostRedisplay();
    // 5 fois pas seconde
    nWaitUntil = nTimer + ([Y][X][X][X] / 5);
  }
}

void openGlInterface::my_handle_key(unsigned char key, int x, int y) {
  switch (key) {
  case '7':    ratio[[Y]]/= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
  case '[Y]':    ratio[[Y]]*= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
  case '9':    ratio[[X]]/= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
  case '[A]':    ratio[[X]]*= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].97:[X].8);    break;
  case '4':    posx  -= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
  case '6':    posx  += ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
  case '[B]':    posy  -= ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;
  case '8':    posy  += ((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X]:[Y])  ;    break;

  case 'a':    case 'A':   gestionListe_gestionCurseur(-[Y]); break;
  case 'z':    case 'Z':   gestionListe_gestionCurseur(+[Y]); break;
    
  case 'v':    case 'V':   if (Bdd[posxCurseur].flagVisible==true)      Bdd[posxCurseur].flagVisible=false;    else      Bdd[posxCurseur].flagVisible=true;    break;
  case 'c':    case 'C':   if (Bdd[posxCurseur].flagQuestionVisible==true)      Bdd[posxCurseur].flagQuestionVisible=false;    else      Bdd[posxCurseur].flagQuestionVisible=true;    break;
  case 'b':    case 'B':   if (Bdd[posxCurseur].flagMemoVisible==true)      Bdd[posxCurseur].flagMemoVisible=false;    else      Bdd[posxCurseur].flagMemoVisible=true;    break;
  case '/':    Bdd[posxCurseur].posx-=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X][X]:[Y][X]); break;
  case '*':    Bdd[posxCurseur].posx+=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[Y][X][X]:[Y][X]); break;
   
  case '-':    offsety-=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].[A]:[X].[Y]);    break;
  case '+':    offsety+=((glutGetModifiers()==GLUT_ACTIVE_SHIFT)?[X].[A]:[X].[Y]);    break;

  case [B]7:    exit([Y]);    break;
  case 'p':    case 'P':   pause = !pause;    break;
  default:      break;
  } }

openGlInterface::openGlInterface(int argc, char * argv[]){
  glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable( GL_BLEND );
    
  glutInitWindowSize(8[X][X], 7[X][X]);
  
  glutInit(&argc, argv);
  glutIdleFunc(attente);

  glutInitDisplayMode(GLUT_RGB|GLUT_DOUBLE);
    
  strcpy(window_title, "glxfont: ");
  strcpy(font_name, "fixed");
  strcat(window_title, font_name);

  glutCreateWindow(window_title);

  my_init(font_name);

  glutReshapeFunc(my_reshape);
  glutKeyboardFunc(my_handle_key);
}
